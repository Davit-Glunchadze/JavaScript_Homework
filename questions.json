[
  {
    "question": "1. რა არის ჯავასკრიპტი?",
    "answers": ["ოპერაციული სისტემა", "პროგრამირების ენა", "მონაცემთა ბაზა", "ტექსტური რედაქტორი"],
    "correctAnswer": "პროგრამირების ენა"
  },
  {
    "question": "2. რა არის key მახასიათებლები ჯავასკრიპტის?",
    "answers": ["მოლეკულური შემადგენლობა", "შესაძლებლობა მუშაობისას დინამიკური ტიპების გამოყენება", "პროგრამირების ორიენტაცია", "დეტალური კომპილაცია"],
    "correctAnswer": "შესაძლებლობა მუშაობისას დინამიკური ტიპების გამოყენება"
  },
  {
    "question": "3. რა განსხვავება var, let შორის?",
    "answers": ["var-ს არ აქვს სკოუპი", "let-ს აქვს ბლოკ-სკოუპი, var-ს კი ფუნქციის სკოუპი", "var შეიძლება მხოლოდ ერთჯერ გამოვიყენოთ", "let ყოველთვის გლობალურია"],
    "correctAnswer": "let-ს აქვს ბლოკ-სკოუპი, var-ს კი ფუნქციის სკოუპი"
  },
  {
    "question": "4. რა განსხვავებაა let | const შორის?",
    "answers": ["let-ს არ შეუძლია ახალი მნიშვნელობის მინიჭება", "const-ს არ შეუძლია ახალი მნიშვნელობის მინიჭება", "let-ს აქვს ფუნქციის სკოუპი", "const-ს არ შეუძლია ცვლადის გამოცხადება"],
    "correctAnswer": "const-ს არ შეუძლია ახალი მნიშვნელობის მინიჭება"
  },
  {
    "question": "5. რა განსხვავებაა '==' '===' შორის?",
    "answers": ["== ადარებს მხოლოდ მნიშვნელობას, ხოლო === ტიპსაც", "=== უფრო ნელია შესრულებაში", "== მხოლოდ რიცხვებს ადარებს", "=== მხოლოდ სტრინგებს ადარებს"],
    "correctAnswer": "== ადარებს მხოლოდ მნიშვნელობას, ხოლო === ტიპსაც"
  },
  {
    "question": "6. რა სახის მონაცემთა ტიპები იცით?",
    "answers": ["პრიმიტიული და რეფერენსი", "მხოლოდ რეფერენსი", "მხოლოდ პრიმიტიული", "წიგნების ტიპები"],
    "correctAnswer": "პრიმიტიული და რეფერენსი"
  },
  {
    "question": "7. რა განსხვავებაა პრიმიტიულ ტიპსა და რეფერენს ტიპს შორის?",
    "answers": ["პრიმიტიული ტიპები ინახება Stack-ში, რეფერენსები - Heap-ში", "პრიმიტიულ ტიპებს არ შეუძლიათ შეცვლა", "რეფერენს ტიპები ყოველთვის ბლოკ-სკოუპში არიან", "პრიმიტიული ტიპები მხოლოდ ფუნქციებში გამოიყენება"],
    "correctAnswer": "პრიმიტიული ტიპები ინახება Stack-ში, რეფერენსები - Heap-ში"
  },
  {
    "question": "8. ჩამოთვალეთ პრიმიტიული და რეფერენს ტიპები.",
    "answers": ["პროგრამირების ენა და სტრუქტურა", "სტრინგი, ნუმერი, ბოულეანი, ნული", "სტრინგი, number, object, function", "null, NaN, undefined, boolean"],
    "correctAnswer": "სტრინგი, number, object, function"
  },
  {
    "question": "9. როგორ აღწერთ ფუნქციას ჯავასკრიპტში?",
    "answers": ["function = myFunction() {}", "function myFunction() {}", "myFunction: function() {}", "var function myFunction() {}"],
    "correctAnswer": "function myFunction() {}"
  },
  {
    "question": "10. რა განსხვავებაა function declaration და function expression შორის?",
    "answers": ["function declaration ხდება hoisted, function expression - არა", "function expression არ შეიძლება გამოიძახო", "function declaration მხოლოდ async შეიძლება იყოს", "function expression-ს ყოველთვის სჭირდება return"],
    "correctAnswer": "function declaration ხდება hoisted, function expression - არა"
  },
  {
    "question": "11. რისთვის გამოიყენება return?",
    "answers": ["ფუნქციის სახელის შესაცვლელად", "ფუნქციიდან მნიშვნელობის დასაბრუნებლად", "ფუნქციის შეჩერებისთვის", "ფუნქციის გლობალურად გამოცხადებისთვის"],
    "correctAnswer": "ფუნქციიდან მნიშვნელობის დასაბრუნებლად"
  },
  {
    "question": "12. დაახასიათე ეროუ ფუნქცია.",
    "answers": [
      "ფუნქცია, რომელიც უმარტივეს სინტაქსს იყენებს",
      "ფუნქცია, რომელიც იყენებს მოკლედ ფორმულირებულ სინტაქსს, სადაც არ არის საჭირო 'function' keyword",
      "ფუნქცია, რომელსაც აქვს return და რომელიც ავტომატურად აბრუნებს მნიშვნელობებს (implicit return)",
      "ფუნქცია, რომელსაც აქვს return, მაგრამ ყოველთვის არ გამოიყენება explicit return"
    ],
    "correctAnswer": "ფუნქცია, რომელიც იყენებს მოკლედ ფორმულირებულ სინტაქსს, სადაც არ არის საჭირო 'function' keyword"
  },
  {
    "question": "13. როგორ მუშაობს პროტოტიპული მემკვიდრეობა ჯავასკრიპტში?",
    "answers": ["პროტოტიპები ინახავს მემკვიდრეობით გადაცემულ მონაცემებს", "პროტოტიპების გამოყენება შეუძლებელია", "ეს არის ობიექტის შექმნის ფორმა", "პროტოტიპი ახორციელებს ფუნქციების გენერაციას"],
    "correctAnswer": "პროტოტიპები ინახავს მემკვიდრეობით გადაცემულ მონაცემებს"
  },
  {
    "question": "14. რას ნიშნავს IFE (IMEDIATELY INVOKED FUNCTION)?",
    "answers": ["ფუნქცია, რომელიც იძახება დაუყოვნებლივ", "ფუნქცია, რომელიც ბრუნდება ობიექტის სახით", "გლობალური ფუნქცია", "ფუნქცია, რომელსაც აქვს მხოლოდ ერთი პარამეტრი"],
    "correctAnswer": "ფუნქცია, რომელიც იძახება დაუყოვნებლივ"
  },
  {
    "question": "15. მასივზე იტერაციის რა განსხვავებული გზები არსებობს?",
    "answers": ["forEach(), map(), reduce(), filter()", "forEach(), map(), find(), splice()", "filter(), reduce(), reverse()", "map(), forEach()"],
    "correctAnswer": "forEach(), map(), reduce(), filter()"
  },
  {
    "question": "16. რა განსხვავებაა for of და for in ციკლებს შორის?",
    "answers": ["for of იტერს ობიექტის მნიშვნელობებზე, for in კლავიშებზე", "for in იტერს ობიექტის მნიშვნელობებზე, for of კლავიშებზე", "for of აქვს მხოლოდ ცვლადი", "for in მხოლოდ array-დან არის"],
    "correctAnswer": "for of იტერს ობიექტის მნიშვნელობებზე, for in კლავიშებზე"
  },
  {
    "question": "17. რა განსხვავებაა for და do while შორის?",
    "answers": ["do while თავიდან შესრულდება, ხოლო for - წინ", "do while ციკლი შეიძლება არასდროს შესრულდეს", "for ციკლში არ შეიძლება გამოვიყენოთ return", "do while ყოველთვის მინიმუმ ერთხელ შესრულდება"],
    "correctAnswer": "do while ყოველთვის მინიმუმ ერთხელ შესრულდება"
  },
  {
    "question": "18. რა არის ქლოჟერი?",
    "answers": ["ფუნქცია, რომელიც ინახავს გარე ფუნქციების ცვლადებს", "მუშაობის ობიექტი", "ამოცანის გადამყვანი", "ფუნქცია, რომელიც ითავსებს ამოცანას"],
    "correctAnswer": "ფუნქცია, რომელიც ინახავს გარე ფუნქციების ცვლადებს"
  },
  {
    "question": "19. რა არის სკოუპი, სკოუპ ჩეინი, ლექსიკალ სკოუპი?",
    "answers": ["ინჰერიტირებული ურთიერთობები", "ფუნქციების და ცვლადების ჩარჩო", "ფუნქციის აღწერის ტექნიკა", "ლექსიკების გამოყენება"],
    "correctAnswer": "ფუნქციების და ცვლადების ჩარჩო"
  },
  {
    "question": "20. რა არის async/await?",
    "answers": ["ასინქრონული ფუნქციის დაწერის გზა", "ვიღებთ პასუხს სენსორული მეთოდებით", "შეკითხვის ობიექტები", "უახლესი ფუნქციის გეგმა"],
    "correctAnswer": "ასინქრონული ფუნქციის დაწერის გზა"
  },
  {
    "question": "21. რომელი სტატუს კოდები იცით?",
    "answers": ["404 - გვერდი არ მოიძებნა, 200 - წარმატებული მოთხოვნა", "500 - სისტემა ვერ მუშაობს, 200 - წარმატებული", "404 - შეცდომა, 500 - ბაზის შეცდომა", "503 - მომსახურების შეცდომა"],
    "correctAnswer": "404 - გვერდი არ მოიძებნა, 200 - წარმატებული მოთხოვნა"
  },
  {
    "question": "22. როგორ იქმნება კლასი ჯავასკრიპტში?",
    "answers": ["class MyClass {}", "function MyClass {}", "class = MyClass {}", "var MyClass {}"],
    "correctAnswer": "class MyClass {}"
  },
  {
    "question": "23. რას გულისხმობს prototype ფროფერთი ჯავასკრიპტში?",
    "answers": ["ინფორმაციის გადასაცემი სისტემა", "მემკვიდრეობის უნარი", "დაწერის რეჟიმი", "რეფერენციის წვდომის მეთოდი"],
    "correctAnswer": "მემკვიდრეობის უნარი"
  },
  {
    "question": "24. რას გულისხმობს მოდულები ჯავასკრიპტში?",
    "answers": ["მოდულების შექმნის მეთოდი", "ფუნქციების ინსტრუმენტები", "სუბიექტების გამოყენება", "კოდი, რომელიც იხსნება"],
    "correctAnswer": "მოდულების შექმნის მეთოდი"
  },
  {
    "question": "25. რა განსხვავებაა -NaN, Null, undefined შორის?",
    "answers": ["-NaN არის რიცხვი, Null არის ცარიელი მნიშვნელობა, Undefined არ არის მნიშვნელობა", "Null არის მონაცემთა ტიპი, -NaN არის შეცდომა", "Undefined არის ცარიელი მნიშვნელობა, Null არ არის", "NaN არის ნომინალური მნიშვნელობა, Undefined არის ცარიელი"],
    "correctAnswer": "-NaN არის რიცხვი, Null არის ცარიელი მნიშვნელობა, Undefined არ არის მნიშვნელობა"
  },
  {
    "question": "26. როგორ შეადარედი ორ ობიექტს ერთმანეთთან?",
    "answers": ["შეუთავსო მათ შევადაროთ ცვლადების მნიშვნელობები", "Object.is() ან JSON.stringify() მეთოდებით", "დამატებითი მეთოდები არ არის", "Array.isArray() და JSON.stringify()"],
    "correctAnswer": "Object.is() ან JSON.stringify() მეთოდებით"
  },
  {
    "question": "27. როგორ დაამატებდი ივენთ ლისენერს ჯავასრიპტში?",
    "answers": ["element.addEventListener(event, handler)", "element.onEvent(handler)", "element.addEvent(event)", "element.eventListener(handler)"],
    "correctAnswer": "element.addEventListener(event, handler)"
  },
  {
    "question": "28. რა არის DOM?",
    "answers": ["დოკუმენტის ობიექტური მოდელი, რომელიც წარმოადგენს HTML დოკუმენტის სტრუქტურას", "მონაცემთა ობიექტების მართვის სისტემა", "როდესაც ვიკვლევთ XML ფორმატში ინფორმაციას", "მონაცემთა გადამუშავების მოდელი"],
    "correctAnswer": "დოკუმენტის ობიექტური მოდელი, რომელიც წარმოადგენს HTML დოკუმენტის სტრუქტურას"
  },
  {
    "question": "29. როგორ მანიპულირებ დომზე ჯავასკრიპტში?",
    "answers": ["document.getElementById() ან document.querySelector()", "window.alert()", "document.createElement()", "JSON.stringify()"],
    "correctAnswer": "document.getElementById() ან document.querySelector()"
  },
  {
    "question": "30. რა განსხვავებაა innerHTML და textContent შორის?",
    "answers": ["innerHTML მუშაობს HTML მარკუპზე, textContent კი მხოლოდ ტექსტზე", "innerHTML სტრინგია, textContent მხოლოდ აბზაცი", "innerHTML არის სტრიქონი, textContent კი HTML ელემენტი", "innerHTML იყენებს ფილტრებს, textContent კი არა"],
    "correctAnswer": "innerHTML მუშაობს HTML მარკუპზე, textContent კი მხოლოდ ტექსტზე"
  },
  {
    "question": "31. რა არის ივენთ ბაბლინგი?",
    "answers": ["პროცესი, როდესაც ივენთი იწყება ქვედა ელემენტიდან და ავა კონტეინერამდე", "როდესაც ივენთი მხოლოდ უმაღლესი ელემენტის ფარგლებში მუშაობს", "შექმნის გლობალური ივენთი", "აირჩიე ტექსტი"],
    "correctAnswer": "პროცესი, როდესაც ივენთი იწყება ქვედა ელემენტიდან და ავა კონტეინერამდე"
  },
  {
    "question": "32. რა არის კოერცია და რა სახის იცით?",
    "answers": ["კოერცია ნიშნავს ტიპების ავტომატურ გადაკეთებას", "კოერცია - ცვლადის ტიპის კონვერტაცია", "პროგრამირების შეცდომა", "კოერცია ყოველთვის ხდება"],
    "correctAnswer": "კოერცია ნიშნავს ტიპების ავტომატურ გადაკეთებას"
  },
  {
    "question": "33. რა განსხვავებაა forEach და map შორის?",
    "answers": ["map აბრუნებს ახალ მასივს, forEach კი არა", "forEach უფრო სწრაფია", "map მხოლოდ ობიექტებზე მუშაობს", "forEach ქმნის ახალ მასივს"],
    "correctAnswer": "map აბრუნებს ახალ მასივს, forEach კი არა"
  },
  {
    "question": "34. რას აკეთებენ მეთოდები: filter, reduce, find, splice, slice?",
    "answers": ["filter ფილტრავს ელემენტებს, reduce აგროვებს შედეგს, find პოულობს პირველ ელემენტს, splice ამატებს ან წაშლას ელემენტებს, slice ამოიღებს ელემენტებს", "filter ბრუნდება ელემენტების სიის გამოკლებით", "splice მხოლოდ ელემენტების შეცვლას ახდენს", "slice მხოლოდ სიმბოლოებზე მუშაობს"],
    "correctAnswer": "filter ფილტრავს ელემენტებს, reduce აგროვებს შედეგს, find პოულობს პირველ ელემენტს, splice ამატებს ან წაშლას ელემენტებს, slice ამოიღებს ელემენტებს"
  },
  {
    "question": "35. როგორ შექმნი მასივის ქოფის?",
    "answers": ["var newArray = oldArray.slice()", "var newArray = oldArray", "var newArray = oldArray.map()", "var newArray = oldArray.concat()"],
    "correctAnswer": "var newArray = oldArray.slice()"
  },
  {
    "question": "36. რა არის სპრედ ოპერატორი?",
    "answers": ["... ოპერატორი, რომელიც დაშლის მასივი ან ობიექტი", "... ოპერატორი, რომელიც ახორციელებს კალკულაციებს", "... ოპერატორი, რომელიც ასრულებს პარამეტრების მინიჭებას", "... ოპერატორი, რომელიც სხვა ტიპების კავშირი ხდება"],
    "correctAnswer": "... ოპერატორი, რომელიც დაშლის მასივი ან ობიექტი"
  },
  {
    "question": "37. რა განსხვავებაა სინქრონულ და ასინქრონულ კოდს შორის?",
    "answers": ["სინქრონული კოდი შესრულდება ნაბიჯ ნაბიჯ, ხოლო ასინქრონული - ერთდროულად", "ასინქრონული კოდი ჯერ ვერ შეასრულებს ფუნქციას", "სინქრონული კოდი მხოლოდ ცვლადებს მუშაობს", "ასინქრონული კოდი ყოველთვის სწრაფად მუშაობს"],
    "correctAnswer": "სინქრონული კოდი შესრულდება ნაბიჯ ნაბიჯ, ხოლო ასინქრონული - ერთდროულად"
  },
  {
    "question": "38. ჯავასკრიპტის ენჯინში სად ინახება პრიმიტიული ინფორმაცია და სად რეფერენს?",
    "answers": ["პრიმიტიული - Stack-ში, რეფერენსი - Heap-ში", "ორივე - Stack-ში", "ორივე - Heap-ში", "პრიმიტიული და რეფერენსი ერთ ადგილზე ინახება"],
    "correctAnswer": "პრიმიტიული - Stack-ში, რეფერენსი - Heap-ში"
  },
  {
    "question": "39. როგორ ჰენდლავ ასინქრონულ კოდს?",
    "answers": ["Promises, async/await", "Callbacks only", "setInterval", "while"],
    "correctAnswer": "Promises, async/await"
  },
  {
    "question": "40. რა განსხვავებაა call(), apply() bind() შორის?",
    "answers": ["call() და apply() გამოძახება პირდაპირ, bind() ინახავს კონტექსტი", "call() ბრუნდება, apply() ქმნის ცვლადებს", "apply() არ იღებს არგუმენტებს", "bind() მხოლოდ ობიექტებს მუშაობს"],
    "correctAnswer": "call() და apply() გამოძახება პირდაპირ, bind() ინახავს კონტექსტი"
  },
  {
    "question": "41. რისთვის არის web worker-ები?",
    "answers": ["გრძელვადიანი, დაბრკოლების გარეშე ასინქრონული ოპერაციების შესასრულებლად", "მოდელების დახურვისათვის", "დამუშავების სკალირებისთვის", "ინტერაქტიული ფუნქციების დასაყენებლად"],
    "correctAnswer": "გრძელვადიანი, დაბრკოლების გარეშე ასინქრონული ოპერაციების შესასრულებლად"
  },
  {
    "question": "42. აღწერე ჰოისთინგი ჯავასკრიპტში.",
    "answers": ["ჯავასკრიპტში ცვლადები და ფუნქციები ითავსებენ თავიანთ ცვლადებს თავში", "ცვლადი შეიძლება გამოჩნდეს პანელებში", "ავტომატური გადახდა", "არ მუშაობს მხოლოდ ოფისის ფუნქციებში"],
    "correctAnswer": "ჯავასკრიპტში ცვლადები და ფუნქციები ითავსებენ თავიანთ ცვლადებს თავში"
  },
  {
    "question": "43. აღწერე იმპლისით კოერცია.",
    "answers": ["ტიპების ავტომატური გადაკეთება", "მონაცემთა დამუშავება", "ოპერატორები და სახელები", "პროგრამირების შეცდომები"],
    "correctAnswer": "ტიპების ავტომატური გადაკეთება"
  },
  {
    "question": "44. რა არის strict-mode ჯავასკრიპტში?",
    "answers": ["კოდი stricte შესრულდება, უფრო უსაფრთხო და ეფექტური", "დაუშვებელია სტანდარტული ფუნქციების შეცვლა", "კოდი ქმნის პერმანენტულ ფუნქციებს", "ფუნქციების დახურვა"],
    "correctAnswer": "კოდი stricte შესრულდება, უფრო უსაფრთხო და ეფექტური"
  },
  {
    "question": "45. აღწერე this ქივორდი.",
    "answers": ["this განისაზღვრება კონტექსტის მიხედვით", "this არის სპეციალური სიტყვა", "this ყოველთვის არის ფუნქცია", "this მიუთითებს ობიექტზე"],
    "correctAnswer": "this განისაზღვრება კონტექსტის მიხედვით"
  },
  {
    "question": "46. self invoking ფუნქცია აღწერე.",
    "answers": ["ფუნქცია, რომელიც უმალვე იწყებს შესრულებას", "მხოლოდ გლობალურ სფეროში მუშაობს", "კოდის ფურცლების გამოყოფა", "მხოლოდ ერთი არგუმენტისთვის"],
    "correctAnswer": "ფუნქცია, რომელიც უმალვე იწყებს შესრულებას"
  },
  {
    "question": "47. რა არის ობიექტის დესტრუქტურირება?",
    "answers": ["მეთოდი, რომელიც საშუალებას გაძლევს ცვლადები სწრაფად მიიღოთ ობიექტიდან", "მეთოდი, რომელიც ქმნის ობიექტს", "საკუთარ ჩარჩოებში დესტრუქტურული ტიპები", "მაღალეფექტური მართვა"],
    "correctAnswer": "მეთოდი, რომელიც საშუალებას გაძლევს ცვლადები სწრაფად მიიღოთ ობიექტიდან"
  },
  {
    "question": "48. რა არის Temporal Dead Zone?",
    "answers": ["დროის მონაკვეთი, როცა ცვლადები ინიცირებული არ არიან", "ავტომატური დელეგირება", "პერიოდი, როცა პარამეტრები გამორთულია", "დროს დაუშვებელი"],
    "correctAnswer": "დროის მონაკვეთი, როცა ცვლადები ინიცირებული არ არიან"
  },
  {
    "question": "49. რა იგულისხმება ჯავასკრიპტის დიზაინ პატერნებში?",
    "answers": ["ოპერაციების ტიპები და სტრატეგიები", "სცენარის ჩარჩო", "გადაწყვეტილებების მართვა", "შესაბამისი ნაბიჯები"],
    "correctAnswer": "ოპერაციების ტიპები და სტრატეგიები"
  },
  {
    "question": "50. რისთვის ვიყენებთ JSON() მეთოდს?",
    "answers": ["მონაცემთა გადაცემის ფორმატად", "ავტომატური JSON ფორმატი", "განსაზღვრილი მეთოდის შეკრება", "საშუალებები"],
    "correctAnswer": "მონაცემთა გადაცემის ფორმატად"
  },
  {
    "question": "51. რა განსხვავებაა TERNARY ოპერატორს და IF ELSE ბლოკს შორის?",
    "answers": ["TERNARY ერთ ხაზზე დაწერილი კონტროლირებადი კონდიციაა, IF ELSE - მრავალმხრივი", "IF ELSE ბლოკი უფრო სწრაფია", "TERNARY ოპერატორი კი არაა მნიშვნელოვანი", "Ternary მხოლოდ სტრინგებს მართავს"],
    "correctAnswer": "TERNARY ერთ ხაზზე დაწერილი კონტროლირებადი კონდიციაა, IF ELSE - მრავალმხრივი"
  }
]
  
